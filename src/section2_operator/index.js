"use strict";

/*
* 単項演算子
*/

// 単項プラス演算子（ + ）
// ・数値以外を Number 型に変換できる
// ・数値へ変換できない値は NaN（"Not a Number"）という特殊な値へ変換される
// ・数値への変換は Numberコンストラクト関数や parseInt関数など明示的に変換をするべき
console.log(+"55"); // 55

console.log(+"文字列") // NaN


// インクリメント演算子（ ++ ）
// ・定義する場所を値の前か後かで挙動に差異がある

// 前置インクリメントは以下の挙動をする
//  1. num1 を +1 をする
//  2. num1 を評価する
let num1 = 1;

console.log(++num1); // 2
console.log(num1); // 2

// 後置インクリメントは前置インクリメントの逆の挙動
let num2 = 1;

console.log(num2++); // 1
console.log(num2); // 2


/*
* 比較演算子
*/

// 等価比較演算子（ == ）
// ・オペランド同士の型が違った場合、後者のオペランドを前者のオペランドと同じ型に変換してから比較する
console.log(1 == "01") // 後者のオペランド "01" が 1 に変換されているため、true が返ってくる
console.log(0 == false) // true
console.log(null == undefined) // true



/*
* ビット演算子
*/

// ビット論理積（ & ）
// オペランド両方が 1 の場合は 1、それ以外は 0 となる
console.log(15 & 9) // 9
console.log(0b1111 & 0b1001) // 0b1001

// ビット論理和（ | ）
// オペランド片方、または両方が 1 の場合は 1、それ以外は 0 となる
console.log(15 | 9) // 15
console.log(0b1111 | 0b1001) // 0b1111

// ビット排他的論理和（ ^ ）
// ビットごとにXOR演算した結果を返す。XORとはビット同士が同じなら 0、異なるなら 1 を返す。
console.log(15 ^ 9) // 6
console.log(0b1111 ^ 0b1001) // 0b0110

// ビット否定（ ~ ）
// オペランドの反転した値を返す。~x の結果は -(x + 1)となる。
console.log(~9) // -10

// 左シフト演算子（ << ）
// ビットの数だけ左へシフトする。左に溢れた値は破棄され、 0 を右に詰めていく。
console.log(9 << 2) // 36
console.log(0b1001 << 2) // 0b10_0100

// 右シフト演算子（ >> ）
// ビットの数だけ右へシフトする。右に溢れた値は破棄され、 左端の値をコピーし左に詰めていく。
console.log(-9 >> 2) // -3
console.log(-0b1001 >> 2) // 1111_1111_1111_1111_1111_1111_1111_1101

// ゼロ埋め右シフト演算子（ >>> ）
// ビットの数だけ右へシフトする。右に溢れた値は破棄され、0 を左に詰めていく。
console.log(-9 >>> 2) // -3
console.log(-0b1001 >>> 2) // 0011_1111_1111_1111_1111_1111_1111_1101






















